# ~
print(~5)
# 4개씩 묶는 이유는 16진수로 계산 가능


#  1111 1111 : 1111 1111 : 1111 1111 : 1111 1010  -> (-6) 이게 왜 -6인가?
#                                      1111 1001
#                                     +0000 0001
#                                      1111 1010
#
#                                                    (-5) 그럼 -5는?
#  0000 0000 : 0000 0000 : 0000 0000 : 0000 0101     ( 5)
#  1111 1111 : 1111 1111 : 1111 1111 : 1111 1010 (1의 보수)         0000 0000 (0)
# +0000 0000   0000 0000   0000 0000   0000 1011 (2의 보수)         1111 1111 (0, 1의 보수)
#                                                                 +0000 0001
#                                                                  0000 0000 (0, 2의 보수)

# 2의 보수 인버트 시킨다음 1을 더해주면 된다

# 정수  실수(알고리즘 있음, 컴퓨터로는 뒤로갈수록 정확하게 표현할 수 없음)

print(~-1)
# 0000 0001 (1)
# 1111 1110 (1의 보수)
# 1111 1111 (-1, 2의 보수)
# 0000 0000 (0)

# << 연산자
a = 4
print(a >> 1)
# 0000 0100
# 0000 0010 (2)?

# and(&) : True and False -> False  1 & 0 -> 0
# or(/) : True and False -> True    1 / 0 -> 1
# XOR(^) : True xor False -> True   1 ^ 0 -> 1
a = 3
print(a & 2)
#  0011 (3)
# &0010 (2)
#  0010
print(a | 8)
#  0011
# |1000
#  1011
print(0x0f ^ 0x06)
#  1111
# ^0110
#  1001


